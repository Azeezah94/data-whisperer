# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1O4MTjMVTxa2ieBY8vOCZOWEwWk6lH1pF
"""

import requests
import re
import networkx as nx
import matplotlib.pyplot as plt

# Step 1: Download Pride and Prejudice from Project Gutenberg
url = "https://www.gutenberg.org/files/1342/1342-0.txt"
response = requests.get(url)
pride_and_prejudice_text = response.text.lower()  # Convert to lowercase for uniformity

# Debug: Print the first 2000 characters of the text to identify chapter markers
print("Sample text from the start of the document:")
print(pride_and_prejudice_text[:2000])

# Step 2: Remove Gutenberg headers and footers
start_marker = "*** start of the project gutenberg ebook"
end_marker = "*** end of the project gutenberg ebook"
main_text = pride_and_prejudice_text[
    pride_and_prejudice_text.find(start_marker) + len(start_marker):
    pride_and_prejudice_text.find(end_marker)
]

# Step 3: Split the text into chapters based on "chapter" markers
chapters = re.split(r"\bchapter \d+\b", main_text, flags=re.IGNORECASE)[1:]

# Debug: Check if chapters were correctly split
print(f"\nNumber of chapters detected: {len(chapters)}")
if len(chapters) > 0:
    print("Sample text from the first chapter:")
    print(chapters[0][:500])
else:
    print("No chapters detected. Review the chapter splitting regular expression.")

# Step 4: Define the main characters and their aliases (all lowercase for consistency)
characters = {
    "elizabeth": ["elizabeth", "lizzy", "miss bennet"],
    "darcy": ["darcy", "mr. darcy"],
    "jane": ["jane", "miss jane bennet"],
    "bingley": ["bingley", "mr. bingley"],
    "collins": ["collins", "mr. collins"],
    "wickham": ["wickham", "mr. wickham"],
    "lydia": ["lydia", "miss lydia bennet"],
    "charlotte": ["charlotte", "miss lucas"],
    "lady catherine": ["lady catherine", "lady catherine de bourgh"],
}

# Debug: Check alias matching in the first chapter
if len(chapters) > 0:
    print("\nAlias matching in the first chapter:")
    for main_character, aliases in characters.items():
        matches = [alias for alias in aliases if alias in chapters[0]]
        print(f"{main_character}: {matches}")
else:
    print("\nCannot perform alias matching because no chapters were detected.")

# Step 4: Extract relationships chapter by chapter
knowledge_graph = nx.Graph()

for chapter_index, chapter in enumerate(chapters, start=1):
    print(f"Processing Chapter {chapter_index}...")
    for main_character, aliases in characters.items():
        if any(alias in chapter for alias in aliases):
            for secondary_character, sec_aliases in characters.items():
                if main_character != secondary_character:
                    if any(sec_alias in chapter for sec_alias in sec_aliases):
                        # Establish or update the relationship
                        if knowledge_graph.has_edge(main_character, secondary_character):
                            knowledge_graph[main_character][secondary_character]["weight"] += 1
                        else:
                            knowledge_graph.add_edge(
                                main_character,
                                secondary_character,
                                weight=1,
                            )

# Step 5: Debugging Information
print(f"\nNumber of nodes: {knowledge_graph.number_of_nodes()}")
print(f"Number of edges: {knowledge_graph.number_of_edges()}")
print("Graph edges with weights:")
for edge in knowledge_graph.edges(data=True):
    print(edge)

# Step 6: Visualize the knowledge graph
plt.figure(figsize=(12, 12))
pos = nx.spring_layout(knowledge_graph, seed=42)
nx.draw(
    knowledge_graph,
    pos,
    with_labels=True,
    node_size=3000,
    font_size=10,
    font_color="white",
    edge_color="gray",
)
edge_labels = nx.get_edge_attributes(knowledge_graph, "weight")
nx.draw_networkx_edge_labels(knowledge_graph, pos, edge_labels=edge_labels)
plt.title("Knowledge Graph of Relationships in Pride and Prejudice", fontsize=16)
plt.show()

import requests
import re
import networkx as nx
import matplotlib.pyplot as plt

# Step 1: Download Pride and Prejudice from Project Gutenberg
url = "https://www.gutenberg.org/files/1342/1342-0.txt"
response = requests.get(url)
pride_and_prejudice_text = response.text.lower()  # Convert to lowercase for uniformity

# Debug: Print the first 5000 characters to analyze the format
print("Sample text from the start of the document:")
print(pride_and_prejudice_text[:5000])

# Step 2: Force locate the start of the story using known first line
start_phrase = "it is a truth universally acknowledged"
start_index = pride_and_prejudice_text.find(start_phrase)

if start_index == -1:
    print("Could not find the start of the story. The document may have unexpected formatting.")
    main_text = ""
else:
    main_text = pride_and_prejudice_text[start_index:]

# Debug: Verify the start of the main text
print("\nStart of the main text:")
print(main_text[:1000])

# Step 3: Define the regular expression for chapters and split
if main_text:
    chapters = re.split(r"\bchapter \d+\b", main_text, flags=re.IGNORECASE)[1:]  # Skip header content
else:
    chapters = []

# Debug: Check the number of detected chapters
print(f"\nNumber of chapters detected: {len(chapters)}")
if len(chapters) > 0:
    print("Sample text from the first chapter:")
    print(chapters[0][:500])
else:
    print("No chapters detected. Ensure that chapter markers are correctly formatted.")

# Step 4: Proceed only if chapters are correctly detected
if len(chapters) > 0:
    # Define the main characters and their aliases
    characters = {
        "elizabeth": ["elizabeth", "lizzy", "miss bennet"],
        "darcy": ["darcy", "mr. darcy"],
        "jane": ["jane", "miss jane bennet"],
        "bingley": ["bingley", "mr. bingley"],
        "collins": ["collins", "mr. collins"],
        "wickham": ["wickham", "mr. wickham"],
        "lydia": ["lydia", "miss lydia bennet"],
        "charlotte": ["charlotte", "miss lucas"],
        "lady catherine": ["lady catherine", "lady catherine de bourgh"],
    }

    # Alias matching debug: Check the first chapter
    print("\nAlias matching in the first chapter:")
    for main_character, aliases in characters.items():
        matches = [alias for alias in aliases if alias in chapters[0]]
        print(f"{main_character}: {matches}")
else:
    print("\nCannot proceed with analysis because no chapters were detected.")

import requests
import re

# Step 1: Download Pride and Prejudice from Project Gutenberg
url = "https://www.gutenberg.org/files/1342/1342-0.txt"
response = requests.get(url)
pride_and_prejudice_text = response.text.lower()  # Convert to lowercase for uniformity

# Step 2: Locate the start of the story
start_phrase = "it is a truth universally acknowledged"
start_index = pride_and_prejudice_text.find(start_phrase)

if start_index == -1:
    print("Could not find the start of the story. The document may have unexpected formatting.")
    main_text = ""
else:
    main_text = pride_and_prejudice_text[start_index:]

# Debug: Print more text after the start of the story to locate chapter markers
print("\nSample text after the start of the story (first 2000 characters):")
print(main_text[:2000])

# Step 1: Print more text to locate chapter markers
print("\nExtended sample text after the start of the story (next 5000 characters):")
print(main_text[:5000])

# Step 2: Use Regular Expression to Search for Chapter Markers
chapter_matches = re.findall(r"\bchapter \w+\b", main_text, flags=re.IGNORECASE)
print(f"\nDetected chapter markers: {chapter_matches[:10]}")  # Show the first 10 matches for verification

# Debugging chapter start positions
for match in chapter_matches[:5]:  # Limit to first 5 for simplicity
    position = main_text.find(match)
    print(f"Marker '{match}' found at position: {position}")

import re
import networkx as nx
import matplotlib.pyplot as plt

# Step 1: Split the text into chapters based on detected markers
chapters = re.split(r"\bchapter [ivxlc]+\b", main_text, flags=re.IGNORECASE)[1:]  # Skip the prelude content

# Debug: Check the number of detected chapters and their samples
print(f"\nNumber of chapters detected: {len(chapters)}")
print("Sample text from the first chapter:")
print(chapters[0][:500])  # First chapter content

# Step 2: Define main characters and aliases
characters = {
    "elizabeth": ["elizabeth", "lizzy", "miss bennet"],
    "darcy": ["darcy", "mr. darcy"],
    "jane": ["jane", "miss jane bennet"],
    "bingley": ["bingley", "mr. bingley"],
    "collins": ["collins", "mr. collins"],
    "wickham": ["wickham", "mr. wickham"],
    "lydia": ["lydia", "miss lydia bennet"],
    "charlotte": ["charlotte", "miss lucas"],
    "lady catherine": ["lady catherine", "lady catherine de bourgh"],
}

# Step 3: Build the knowledge graph
knowledge_graph = nx.Graph()

for chapter_index, chapter in enumerate(chapters, start=1):
    print(f"Processing Chapter {chapter_index}...")
    for main_character, aliases in characters.items():
        if any(alias in chapter for alias in aliases):
            for secondary_character, sec_aliases in characters.items():
                if main_character != secondary_character and any(sec_alias in chapter for sec_alias in sec_aliases):
                    # Add or update the relationship in the graph
                    if knowledge_graph.has_edge(main_character, secondary_character):
                        knowledge_graph[main_character][secondary_character]["weight"] += 1
                    else:
                        knowledge_graph.add_edge(main_character, secondary_character, weight=1)

# Step 4: Debugging the graph structure
print(f"\nNumber of nodes: {knowledge_graph.number_of_nodes()}")
print(f"Number of edges: {knowledge_graph.number_of_edges()}")
print("Graph edges with weights:")
for edge in knowledge_graph.edges(data=True):
    print(edge)

# Step 5: Visualize the knowledge graph
plt.figure(figsize=(12, 12))
pos = nx.spring_layout(knowledge_graph, seed=42)
nx.draw(
    knowledge_graph,
    pos,
    with_labels=True,
    node_size=3000,
    font_size=10,
    font_color="white",
    edge_color="gray",
)
edge_labels = nx.get_edge_attributes(knowledge_graph, "weight")
nx.draw_networkx_edge_labels(knowledge_graph, pos, edge_labels=edge_labels)
plt.title("Knowledge Graph of Relationships in Pride and Prejudice", fontsize=16)
plt.show()

import re
import networkx as nx
import matplotlib.pyplot as plt

# Step 1: Split the text into chapters based on detected markers
chapters = re.split(r"\bchapter [ivxlc]+\b", main_text, flags=re.IGNORECASE)[1:]  # Skip the prelude content

# Debug: Check the number of detected chapters
print(f"\nNumber of chapters detected: {len(chapters)}")

# Step 2: Define main characters and aliases
characters = {
    "elizabeth": ["elizabeth", "lizzy", "miss bennet"],
    "darcy": ["darcy", "mr. darcy"],
    "jane": ["jane", "miss jane bennet"],
    "bingley": ["bingley", "mr. bingley"],
    "collins": ["collins", "mr. collins"],
    "wickham": ["wickham", "mr. wickham"],
    "lydia": ["lydia", "miss lydia bennet"],
    "charlotte": ["charlotte", "miss lucas"],
    "lady catherine": ["lady catherine", "lady catherine de bourgh"],
}

# Step 3: Initialize cumulative graph
cumulative_graph = nx.Graph()

# Step 4: Process each chapter and create individual graphs
for chapter_index, chapter in enumerate(chapters, start=1):
    print(f"Processing Chapter {chapter_index}...")

    # Create a graph for the current chapter
    chapter_graph = nx.Graph()

    # Extract interactions for the current chapter
    for main_character, aliases in characters.items():
        if any(alias in chapter for alias in aliases):
            for secondary_character, sec_aliases in characters.items():
                if main_character != secondary_character and any(sec_alias in chapter for sec_alias in sec_aliases):
                    # Add or update the relationship in the chapter graph
                    if chapter_graph.has_edge(main_character, secondary_character):
                        chapter_graph[main_character][secondary_character]["weight"] += 1
                    else:
                        chapter_graph.add_edge(main_character, secondary_character, weight=1)

    # Add chapter graph edges to the cumulative graph
    for u, v, data in chapter_graph.edges(data=True):
        if cumulative_graph.has_edge(u, v):
            cumulative_graph[u][v]["weight"] += data["weight"]
        else:
            cumulative_graph.add_edge(u, v, weight=data["weight"])

    # Visualize the chapter graph
    plt.figure(figsize=(10, 10))
    pos = nx.spring_layout(chapter_graph, seed=42)
    nx.draw(
        chapter_graph,
        pos,
        with_labels=True,
        node_size=2000,
        font_size=10,
        font_color="white",
        edge_color="gray",
    )
    edge_labels = nx.get_edge_attributes(chapter_graph, "weight")
    nx.draw_networkx_edge_labels(chapter_graph, pos, edge_labels=edge_labels)
    plt.title(f"Character Interactions in Chapter {chapter_index}", fontsize=16)
    plt.show()

# Step 5: Visualize the cumulative graph
plt.figure(figsize=(12, 12))
pos = nx.spring_layout(cumulative_graph, seed=42)
nx.draw(
    cumulative_graph,
    pos,
    with_labels=True,
    node_size=3000,
    font_size=10,
    font_color="white",
    edge_color="gray",
)
edge_labels = nx.get_edge_attributes(cumulative_graph, "weight")
nx.draw_networkx_edge_labels(cumulative_graph, pos, edge_labels=edge_labels)
plt.title("Cumulative Character Interactions in Pride and Prejudice", fontsize=16)
plt.show()

import re
import networkx as nx
import matplotlib.pyplot as plt

# Step 1: Split the text into chapters based on detected markers
chapters = re.split(r"\bchapter [ivxlc]+\b", main_text, flags=re.IGNORECASE)[1:]  # Skip the prelude content

# Debug: Check the number of detected chapters
print(f"\nNumber of chapters detected: {len(chapters)}")

# Step 2: Define main characters and aliases
characters = {
    "elizabeth": ["elizabeth", "lizzy", "miss bennet"],
    "darcy": ["darcy", "mr. darcy"],
    "jane": ["jane", "miss jane bennet"],
    "bingley": ["bingley", "mr. bingley"],
    "collins": ["collins", "mr. collins"],
    "wickham": ["wickham", "mr. wickham"],
    "lydia": ["lydia", "miss lydia bennet"],
    "charlotte": ["charlotte", "miss lucas"],
    "lady catherine": ["lady catherine", "lady catherine de bourgh"],
}

# Helper function to extract relationships
def extract_relationships(text, character1_aliases, character2_aliases):
    """Extract relationship descriptions based on proximity in text."""
    sentences = re.split(r'[.!?]', text)  # Split into sentences
    for sentence in sentences:
        if any(alias in sentence for alias in character1_aliases) and any(alias in sentence for alias in character2_aliases):
            return sentence.strip()  # Return the sentence as the relationship description
    return "interacts with"  # Default if no context is found

# Step 3: Initialize cumulative graph
cumulative_graph = nx.Graph()

# Step 4: Process each chapter and create individual graphs
for chapter_index, chapter in enumerate(chapters, start=1):
    print(f"Processing Chapter {chapter_index}...")

    # Create a graph for the current chapter
    chapter_graph = nx.Graph()

    # Extract interactions for the current chapter
    for main_character, aliases in characters.items():
        if any(alias in chapter for alias in aliases):
            for secondary_character, sec_aliases in characters.items():
                if main_character != secondary_character and any(sec_alias in chapter for sec_alias in sec_aliases):
                    # Extract a relationship description
                    relationship = extract_relationships(chapter, aliases, sec_aliases)

                    # Add or update the relationship in the chapter graph
                    if chapter_graph.has_edge(main_character, secondary_character):
                        chapter_graph[main_character][secondary_character]["weight"] += 1
                    else:
                        chapter_graph.add_edge(main_character, secondary_character, weight=1, relationship=relationship)

    # Add chapter graph edges to the cumulative graph
    for u, v, data in chapter_graph.edges(data=True):
        if cumulative_graph.has_edge(u, v):
            cumulative_graph[u][v]["weight"] += data["weight"]
        else:
            cumulative_graph.add_edge(u, v, weight=data["weight"], relationship=data["relationship"])

    # Visualize the chapter graph
    plt.figure(figsize=(10, 10))
    pos = nx.spring_layout(chapter_graph, seed=42)
    nx.draw(
        chapter_graph,
        pos,
        with_labels=True,
        node_size=2000,
        font_size=10,
        font_color="white",
        edge_color="gray",
    )
    edge_labels = nx.get_edge_attributes(chapter_graph, "relationship")
    nx.draw_networkx_edge_labels(chapter_graph, pos, edge_labels=edge_labels)
    plt.title(f"Character Relationships in Chapter {chapter_index}", fontsize=16)
    plt.show()

# Step 5: Visualize the cumulative graph
plt.figure(figsize=(12, 12))
pos = nx.spring_layout(cumulative_graph, seed=42)
nx.draw(
    cumulative_graph,
    pos,
    with_labels=True,
    node_size=3000,
    font_size=10,
    font_color="white",
    edge_color="gray",
)
edge_labels = nx.get_edge_attributes(cumulative_graph, "relationship")
nx.draw_networkx_edge_labels(cumulative_graph, pos, edge_labels=edge_labels)
plt.title("Cumulative Character Relationships in Pride and Prejudice", fontsize=16)
plt.show()